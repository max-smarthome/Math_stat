#Произвести вычисления как в пункте 2, но с вычислением intercept.
# Учесть, что изменение коэффициентов должно производиться на каждом шаге одновременно
# (то есть изменение одного коэффициента не должно влиять на изменение другого во время одной итерации).
import numpy as np


x = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])
y = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])
n = len(y)

def mse(B0, B1, y=y, x=x, n = len(y)):
    return np.sum((B0 + B1 * x - y) **2)

alpha = 3e-5
B1 = 1
B0 = 1

for i in range(2000001):
    B0 -= alpha * (2 / n) * np.sum((B0 + B1 * x - y))
    B1 -= alpha * (2/n) * np.sum((B0 + B1 * x - y) * x)
    if i % 200000 == 0:
        print(f'iter={i} B0={B0} B1={B1} mse={mse(B0, B1)}')

'''iter=0 B0=1.03645 B1=5.035600238199999 mse=661575.0057138731
iter=200000 B0=423.0641191951932 B1=2.7759392846688287 mse=65834.90109905561
iter=400000 B0=443.1714129728508 B1=2.6279429648995087 mse=64706.70890796843
iter=600000 B0=444.1294289093944 B1=2.620891651358432 mse=64704.14783878681
iter=800000 B0=444.1750737656774 B1=2.620555690148486 mse=64704.14202499428
iter=1000000 B0=444.1772485237595 B1=2.6205396832110983 mse=64704.14201179662
iter=1200000 B0=444.17735214053295 B1=2.6205389205574408 mse=64704.14201176667
iter=1400000 B0=444.17735707737086 B1=2.620538884220684 mse=64704.14201176657
iter=1600000 B0=444.177357312503 B1=2.620538882490034 mse=64704.14201176662
iter=1800000 B0=444.1773573224922 B1=2.6205388824165103 mse=64704.1420117666
iter=2000000 B0=444.1773573224922 B1=2.6205388824165103 mse=64704.1420117666'''